[{"name":"app.R","content":"# A lightweight ShinyApp for coding of text data for qualitative analysis\n# QualCA (pronounced like Quokka; not yet final)\n# Written by William Ngiam\n# Started on Sept 15 2024\n# Version 0.1.2 (Oct 15 2024)\n#\n# Motivated by the ANTIQUES project\n#\n# Wishlist\n# Take in various corpus input files\n# Edit text viewer to show all relevant information\n# Add codebook, codes, extracts - have all linked and viewable.\n# Apply specific colours for the code\n# Collaborative coding <- maybe a google sheet that contains code/extracts...\n# Floating menus?\n# Dealing with line breaks\n# Highlight extracts that are selected in the codebook\n# \n# Glossary\n# Corpus: The body of text to be qualitatively analysed\n# Document: Each item that makes up the corpus\n# Extract: The harvested section of text that is coded\n#\n# --- #\n\n# Load required packages\nlibrary(tools)\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(shinyalert)\nlibrary(shinyjs)\nlibrary(DT) # for data presentation purposes\nlibrary(tibble)\nlibrary(dplyr) # for data wrangling\nlibrary(readr)\nlibrary(stringr) # for handling strings\n\n# Workaround for Chromium Issue 468227\n# Copied from https://shinylive.io/r/examples/#r-file-download\ndownloadButton <- function(...) {\n  tag <- shiny::downloadButton(...)\n  tag$attribs$download <- NULL\n  tag\n}\n\n### UI ###\nui <- dashboardPage(\n  dashboardHeader(title = \"QualCA - Qualitative Coding App\",\n                  titleWidth = 350),\n  dashboardSidebar(width = 350,\n                   fluidPage(\n                     HTML(\"<br>To use this app, upload your corpus CSV file using the button below. A menu will appear\n              to select the column that contains the text to be coded.<br><br>\n           If you are returning to the app, you may upload your previously saved codebook by uploading using the button below.<br><br>\n           You may scroll through the documents by pressing the 'previous' and 'next' button, or typing in the numeric value into the bar.<br><br>\n           To add an extract to the codebook, highlight the text in the document and press the 'Add Selected Text to Codebook' button. It will appear underneath\n           the Extract column. You can then add a Code or Theme by double clicking on a cell within the codebook.<br><br>\")),\n                   fileInput(\"corpusFile\", \"Add Corpus CSV File\",\n                             accept = c(\"text/csv\", \"text/comma-separated-values,text/plain\", \".csv\")), # Upload the corpus of documents to-be-analysed\n                   uiOutput(\"documentTextSelector\"),\n                   fileInput(\"codebookFile\", \"Add Codebook CSV File\",\n                             accept = c(\"text/csv\", \"text/comma-separated-values,text/plain\", \".csv\")), # Upload any existing codebook\n                   uiOutput(\"codebookSelector\"),\n                   fluidPage(\"Download Codebook\"),\n                   fluidPage(downloadButton(\"downloadData\",\n                                            label = \"Download Codebook\")),\n                   HTML(\"<br>\"),\n                   fluidPage(\"Created by William Ngiam\")\n  ),\n  dashboardBody(\n    useShinyjs(),  # Initialize shinyjs\n    fluidRow(\n      box(title = \"Document Viewer\", width = 6, solidHeader = TRUE, status = \"primary\",\n          fluidPage(\n            fluidRow(\n              column(width = 5,\n                     numericInput(inputId = \"documentID_viewer\",\n                                  label = \"Document #\",\n                                  value = \"currentDocumentID\")),\n              column(width = 5,\n                     offset = 1,\n                     HTML(\"<strong>Document Navigation <\/strong><br>\"),\n                     actionButton(\"prevDocument\", \"Previous\"),\n                     actionButton(\"nextDocument\", \"Next\")))),\n          bootstrapPage(\n            tags$style(\n              \"#textDisplay {\n                    overflow-y: scroll;\n                    height: 40vh;\n                }\"\n            ),\n            uiOutput(\"textDisplay\"),\n            tags$script('\n                          function getSelectionText() {\n                            var text = \"\";\n                            if (window.getSelection) {\n                              text = window.getSelection().toString();\n                            } else if (document.selection) {\n                              text = document.selection.createRange().text;\n                            }\n                            return text;\n                          }\n                          \n                          document.onmouseup = document.onkeyup = document.onselectionchange = function() {\n                            var selection = getSelectionText();\n                            Shiny.onInputChange(\"extract\",selection);\n                          };\n                          ')\n          )),\n      box(title = \"Quick Look\", width = 6, solidHeader = TRUE, status = \"primary\",\n          fluidPage(DTOutput(\"counterTable\")\n          )\n      ),\n    ),\n    fluidRow(\n      box(title = \"Codebook\", width = 12, solidHeader = TRUE, status = \"primary\",\n          actionButton(\"addSelectedText\", \"Add Selected Text as Extract\"),\n          actionButton(\"deleteExtract\", \"Delete Extract from Codebook\"),\n          actionButton(\"addColumn\", \"Add Column to Codebook\"),\n          actionButton(\"removeColumn\", \"Remove Column from Codebook\"),\n          HTML(\"<br><br>\"),\n          DTOutput(\"codebookTable\")))\n  )\n)\n\n### SERVER ###\nserver <- function(input, output, session) {\n  # Reactive values to store data and codebook\n  values <- reactiveValues(\n    corpus = NULL, # the text data to be analysed\n    documentTextColumn = NULL, # the column which contains document text\n    selectedText = NULL,\n    codebook = tibble(Theme = as.character(), \n                      Code = as.character(), \n                      Extract = as.character(), \n                      Document_ID = as.numeric()),\n    counter = data.frame(),\n    currentDocumentIndex = 1,\n    nDocuments = 1,\n    selection = NULL,\n    thisExtract = NULL\n  )\n  \n  ### FUNCTIONS ###\n  # Update text display based on currentDocumentIndex and documentTextColumn\n  updateTextDisplay <- function() {\n    req(values$corpus, values$documentTextColumn)\n    text <- values$corpus[[values$documentTextColumn]][values$currentDocumentIndex]\n    #text <- sub(\"<span*/span>\",\"\",text) # Remove any leftover HTML\n    text <- gsub(pattern = \"\\n\", replacement = \"\", text) # Remove line breaks because they \"break\" the app...\n    \n    # Add highlights here by adding HTML tags to text\n    # Retrieve document ID\n    currentDoc <- values$currentDocumentIndex\n    \n    # Get saved extracts for document ID\n    currentExtracts <- values$codebook %>% \n      dplyr::filter(Document_ID == currentDoc)\n    oldStrings = currentExtracts$Extract\n    \n    if (length(oldStrings) > 0) {\n      # Detect where extracts start and finish in text\n      stringLocs <- as.data.frame(str_locate(text,paste0(\"\\\\Q\",oldStrings,\"\\\\E\")))\n      stringLocs <- na.omit(stringLocs) # omit NA where matches don't work with special characters\n      addedStringStart = last(stringLocs$start)\n      # Sort these locations by their starting order\n      stringLocs <- stringLocs %>% \n        arrange(start)\n      \n      # If more than one string, check for overlaps (leetcode 56)\n      if (length(oldStrings) > 1) {\n        # Write the first interval to start result\n        reducedStrings <- tibble(start = as.numeric(),\n                                 end = as.numeric()) %>% \n          tibble::add_row(start = head(stringLocs$start, n = 1), \n                          end = head(stringLocs$end, n = 1))\n        \n        for (i in 1:nrow(stringLocs)) {\n          # Retrieve the next interval\n          thisStringStart <- stringLocs$start[i]\n          thisStringEnd <- stringLocs$end[i]\n          # Check for overlap\n          if (between(thisStringStart,\n                      tail(reducedStrings, n = 1)$start,tail(reducedStrings, n = 1)$end)) {\n            # If overlap, change value of interval\n            reducedStrings[nrow(reducedStrings),ncol(reducedStrings)] = max(thisStringEnd,tail(reducedStrings, n = 1)$end)\n          }\n          else {\n            # If no overlap, add the interval\n            reducedStrings <- reducedStrings %>% \n              add_row(start = thisStringStart, end = thisStringEnd)\n          }\n        }\n        # Arrange in descending order for inserting HTML\n        stringLocs <- reducedStrings %>% \n          arrange(desc(start))\n      }\n      \n      for (i in 1:nrow(stringLocs)) {\n        # Get start and end\n        stringStart <- stringLocs$start[i]\n        stringEnd <- stringLocs$end[i]\n        theString <- str_sub(text,stringStart,stringEnd)\n        # Get string\n        if (stringStart == addedStringStart) {\n          str_sub(text,stringStart,stringEnd) <- paste0(\"<span id=\\\"lastString\\\" style=\\\"background-color: powderblue\\\">\",theString,\"<\/span>\")\n        } else {\n          str_sub(text,stringStart,stringEnd) <- paste0(\"<span style=\\\"background-color: powderblue\\\">\",theString,\"<\/span>\")\n        }\n      }\n    }\n    \n    # Hope it works\n    output$textDisplay <- renderUI({\n      tags$div(id = \"textDisplay\",\n               tags$p(HTML(text), id = \"currentText\", style = \"font-size: 20px\"),\n               tags$script('\n                            lastString.scrollIntoView();\n                           '))\n    })\n  }\n  \n  # Update document viewer ID number\n  updateDocumentID <- function() {\n    updateNumericInput(\n      session,\n      inputId = \"documentID_viewer\",\n      value = values$currentDocumentIndex,\n      max = values$nDocuments)\n  }\n  \n  # Save codebook locally\n  saveCodebook <- function() {\n    req(values$codebook)\n    write.csv(values$codebook, \"temp_codebook.csv\", row.names = FALSE)\n  }\n  \n  # Render codebook\n  renderCodebook <- function() {\n    output$codebookTable <- renderDT({\n      datatable(values$codebook, editable = TRUE, rownames = FALSE)\n    })\n  }\n  \n  # Render code counter\n  renderCounter <- function() {\n    values$counter <- values$codebook %>% \n      count(Code, name = \"Instances\")\n    \n    output$counterTable <- renderDT({\n      datatable(values$counter, \n                editable = list(target = \"cell\",\n                                disable = list(columns = 1)),\n                rownames = FALSE)\n    })\n  }\n  \n  ### UPLOADING DATA ###\n  # Load corpus CSV file and update column selector\n  observeEvent(input$corpusFile, {\n    req(input$corpusFile)\n    if (file_ext(input$corpusFile$datapath) == \"csv\") {\n      values$corpus <- read.csv(input$corpusFile$datapath, stringsAsFactors = FALSE)\n    } else if (file_ext(input$corpusFile$datapath) == \"txt\") {\n      values$corpus <- read.delim(input$corpusFile$datapath, header = FALSE, sep = \"\\n\")\n    }\n    colnames <- colnames(values$corpus)\n    values$documentTextColumn <- colnames[1]  # Default to the first column\n    values$currentDocumentIndex <- 1  # Reset index on new file load\n    values$nDocuments <- nrow(values$corpus) # Get number of documents\n    \n    output$documentTextSelector <- renderUI({\n      req(values$corpus)\n      selectInput(\"documentTextColumn\", \"Select Text Column\",\n                  choices = colnames,\n                  selected = values$documentTextColumn)\n    })\n    \n    updateTextDisplay()\n    renderCodebook()\n    renderCounter()\n    \n    updateSelectInput(session, \"codebookSelector\", choices = values$codebook$Theme, selected = NULL)\n  })\n  \n  # Update codebook on upload\n  observeEvent(input$codebookFile, {\n    req(input$codebookFile)\n    values$codebook <- read.csv(input$codebookFile$datapath, stringsAsFactors = FALSE)\n    colnames <- colnames(values$codebook)\n    renderCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  \n  ## DOCUMENT NAVIGATION ##\n  # Update display after document text column is selected\n  observeEvent(input$documentTextColumn, {\n    values$documentTextColumn <- input$documentTextColumn\n    updateTextDisplay()\n  })\n  \n  # Updated display after document ID is scrolled\n  observeEvent(input$documentID_viewer, {\n    req(values$corpus)\n    if (input$documentID_viewer > nrow(values$corpus)) {\n      values$currentDocumentIndex <- nrow(values$corpus)\n      updateTextDisplay()\n    } else if (values$currentDocumentIndex > 1) {\n      values$currentDocumentIndex <- input$documentID_viewer\n      # Updated text display\n      updateTextDisplay()\n    }\n  })\n  \n  # Action button for previous document\n  observeEvent(input$prevDocument, {\n    req(values$corpus)\n    if (values$currentDocumentIndex > 1) {\n      values$currentDocumentIndex <- values$currentDocumentIndex - 1\n      \n      # Updated text display\n      updateDocumentID()\n      updateTextDisplay()\n      \n    }\n  })\n  \n  # Action button for next document\n  observeEvent(input$nextDocument, {\n    req(values$corpus)\n    if (values$currentDocumentIndex < nrow(values$corpus)) {\n      values$currentDocumentIndex <- values$currentDocumentIndex + 1\n      updateDocumentID()\n      updateTextDisplay()\n    }\n  })\n  \n  ## CODEBOOK ACTIONS ##\n  # Save after any edits to the codebook\n  observeEvent(input$codebookTable_cell_edit, {\n    values$codebook <- editData(values$codebook, input$codebookTable_cell_edit, rownames = FALSE, 'codebookTable')\n    saveCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  # Add selected text as extract\n  observeEvent(input$addSelectedText, {\n    req(values$codebook,input$extract)\n    selectedText <- input$extract # Highlighted text within document to-be-extracted\n    \n    # If code is selected in counter, add that code to the extracted text. Works for multiple selected rows\n    if (!is.null(input$counterTable_rows_selected)) {\n      selectedRow <- input$counterTable_rows_selected\n      allCodes <- values$counter$Code\n      selectedCode <- allCodes[selectedRow]\n    } else {\n      selectedCode = \"\"\n    }\n    \n    # Append the selected text to codebook as extract\n    values$codebook <- values$codebook %>% \n      add_row(Theme = \"\",\n              Code = selectedCode,\n              Extract = selectedText,\n              Document_ID = values$currentDocumentIndex)\n    \n    renderCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  # Delete extract from codebook\n  observeEvent(input$deleteExtract, {\n    req(input$codebookTable_rows_selected)\n    whichRow <- input$codebookTable_rows_selected # highlighted rows in codebook\n    values$codebook <- values$codebook[-whichRow,]\n    renderCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  # Get column name in response to add button\n  observeEvent(input$addColumn, {\n    req(values$codebook)\n    showModal(modalDialog(\n      textInput(\"colName\", \"Name of new column in codebook:\",\n                placeholder = \"Notes\"),\n      footer = tagList(modalButton(\"Cancel\"),\n                       actionButton(\"addCol\",\"OK\"))))\n  })\n  \n  # Add column to codebook after getting name\n  observeEvent(input$addCol, {\n    req(values$codebook)\n    newColName = input$colName\n    values$codebook <- values$codebook %>% \n      mutate(newColumn = as.character(\"\")) %>%\n      rename_with(~ newColName, newColumn)\n    \n    removeModal()\n    renderCodebook()\n  })\n  \n  # Remove column name in response to add button\n  observeEvent(input$removeColumn, {\n    req(values$codebook)\n    showModal(modalDialog(\n      selectInput(\"minusCol\", \"Select which column to remove\",\n                  choices = colnames(values$codebook)),\n      footer = tagList(modalButton(\"Cancel\"),\n                       actionButton(\"minusColButton\",\"OK\"))))\n  })\n  \n  # Remove column to codebook after getting selection\n  observeEvent(input$minusColButton, {\n    req(values$codebook)\n    minusColName = input$minusCol\n    values$codebook <- values$codebook %>% \n      select(-matches(paste0(minusColName)))\n    \n    removeModal()\n    renderCodebook()\n  })\n  \n  \n  # Save and apply rewording of code\n  observeEvent(input$counterTable_cell_edit, {\n    # Update counter\n    values$counter <- editData(values$counter, input$counterTable_cell_edit, rownames = FALSE, 'counterTable')\n    \n    ## Get previous code value\n    # Recreate previous counter\n    oldCounterTable <- values$codebook %>% \n      count(Code, name = \"Instances\")\n    \n    # Retrieve old Code\n    info = input$counterTable_cell_clicked\n    changeRow = info$row\n    changeCol = info$col\n    oldValue = info$value\n    \n    # Retrieve new Code\n    new_info = input$counterTable_cell_edit\n    newValue = new_info$value\n    \n    # Replace strings in codebook\n    values$codebook$Code[values$codebook$Code == oldValue] <- as.character(newValue)\n    renderCodebook()\n  })\n  \n  # Download handler for the codebook\n  output$downloadData <- downloadHandler(\n    filename = function() {\n      paste(\"codebook-\", Sys.Date(), \".csv\", sep = \"\")\n    },\n    content = function(file) {\n      write.csv(values$codebook, file, row.names = FALSE)\n    }\n  )\n}\n\nshinyApp(ui, server)","type":"text"},{"name":"LICENSE","content":"MIT License\n\nCopyright (c) 2024 William Ngiam\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n","type":"text"},{"name":"README.md","content":"# _QualCA_ â€“ Qualitative Coding App\n\n**_QualCA_** (pronounced _quokka_, like the small Australian marsupial) is a lightweight in-browser _R Shiny_ app for extracting and coding texts for qualitative analysis.\n\nThis repository contains the R Shiny code that is deployed at https://palm-lab.github.io/QualCA. You can run the ShinyApp locally within R / RStudio, making changes to the underlying code as needed. One advantage of running the app on your local device is that a temporary codebook file is automatically saved as a back-up for any unexpected crashes.\n\n# How to use the app\n\nOpen the app in R Studio by opening the code file (`app.R`). A **Run App** button should appear in the top right of the code editor.\n\n1. Organize your **corpus** as a CSV file, such that the each **document** is a different row and the **document text** is contained in one column.\n2. Upload your **corpus** CSV to **_QualCA_** using the button on the left-side menu. A menu will appear below to select the CSV column that contains the to-be-coded text, in case the corpus contains mutliple columns.\n3. If you are returning to the **_QualCA_** app, you can upload your previously saved codebook CSV using the button on the left-side menu to continue your analysis.\n4. You can scroll through the documents by pressing the 'previous' or 'next' buttons in the _Document Viewer_ pane of the app. You can also type in a numeric value into the _Document #_ bar to navigate to that document.\n5. To add an extract to the codebook, highlight the text in the document using your cursor and press the 'Add Selected Text as Extract' button in the _Codebook_ pane. When clicked, the highlighted text will appear in the _Extract_ column, and will be highlighted in blue in the _Document Viewer_. \n6. You can then add a Code or Theme to an extract by double clicking on the relevant cell within the codebook table, and typing the new Code.\n7. A _Counter_ pane in the top-right of the app shows how many extracts are associated with each Code. You can edit a Code by double clicking on it in the _Counter_, and typing in the new Code. This will change the Code for all extracts associated with the old Code.\n8. To save your progress, you can click the _Download Codebook_ button in the left-side menu. The Codebook is saved as a CSV file, which you can upload to **_QualCA_** on your next visit.\n\n# Acknowledgements\n\nThe **_QualCA_** app is [hosted on Github Pages at https://palm-lab.github.io/QualCA](https://palm-lab.github.io/QualCA) using the [shinylive](https://posit-dev.github.io/r-shinylive/) package, and makes use of this [helpful StackOverflow answer by user GGamba](https://stackoverflow.com/questions/42274461/can-shiny-recognise-text-selection-with-mouse-highlighted-text). \n\nThis app was created for an ongoing research project with Carly Stagg, Natasha van Antwerpen and Ella Moeck, who brought knowledge on how to conduct qualitative analysis, shared what would be desirable features, and tested earlier versions of the app.\n\n[Clinton Hadinata](https://github.com/hadinata) provided debugging help and useful advice on how to handle overlapping intervals.\n\nWilliam Ngiam created this app while employed as a Lecturer in the School of Psychology at the University of Adelaide.","type":"text"},{"name":"temp_codebook.csv","content":"\"Theme\",\"Code\",\"Extract\",\"Document_ID\"\n\"\",\"disillusion with society\",\"It truly broke my heart because i realised at that moment that this modern world isnt for me.\",1\n","type":"text"}]
