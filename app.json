[{"name":"app.R","content":"# A lightweight ShinyApp for coding of text data for qualitative analysis\n# QualCA (pronounced like Quokka; not yet final)\n# Written by William Ngiam\n# Started on September 15, 2024\n#\n# Motivated by the ANTIQUES project\n#\n# Wishlist\n# Take in various corpus input files\n# Edit text viewer to show all relevant information\n# Add codebook, codes, extracts - have all linked and viewable.\n# Collaborative coding <- maybe a google sheet that contains code/extracts...\n# Floating menus?\n# Dealing with line breaks\n# Highlight extracts that are selected in the codebook\n# \n# Glossary\n# Corpus: The body of text to be qualitatively analysed\n# Document: Each item that makes up the corpus\n# Extract: The harvested section of text that is coded\n#\n# --- #\n\n# Load required packages\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(shinyjs)\nlibrary(DT) # for data presentation purposes\nlibrary(tibble)\nlibrary(dplyr) # for data wrangling\nlibrary(stringr) # for handling strings\n\n# Workaround for Chromium Issue 468227\n# Copied from https://shinylive.io/r/examples/#r-file-download\ndownloadButton <- function(...) {\n  tag <- shiny::downloadButton(...)\n  tag$attribs$download <- NULL\n  tag\n}\n\n### UI ###\nui <- dashboardPage(\n  dashboardHeader(title = \"Qualitative Coding App\"),\n  dashboardSidebar(\n    fluidPage(\n      HTML(\"<br>To use this app, upload your corpus CSV file using the button below. A menu will appear\n              to select the column that contains the text to be coded.<br><br>\n           If you are returning to the app, you may upload your previously saved codebook by uploading using the button below.<br><br>\n           You may scroll through the documents by pressing the 'previous' and 'next' button, or typing in the numeric value into the bar.<br><br>\n           To add an extract to the codebook, highlight the text in the document and press the 'Add Selected Text to Codebook' button. It will appear underneath\n           the Extract column. You can then add a Code or Theme by double clicking on a cell within the codebook.<br><br>\")),\n    fileInput(\"corpusFile\", \"Add Corpus CSV File\",\n              accept = c(\"text/csv\", \"text/comma-separated-values,text/plain\", \".csv\")), # Upload the corpus of documents to-be-analysed\n    uiOutput(\"documentTextSelector\"),\n    fileInput(\"codebookFile\", \"Add Codebook CSV File\",\n              accept = c(\"text/csv\", \"text/comma-separated-values,text/plain\", \".csv\")), # Upload any existing codebook\n    uiOutput(\"codebookSelector\"),\n    fluidPage(\"Download Codebook\"),\n    fluidPage(downloadButton(\"downloadData\",\n                             label = \"Download Codebook\")),\n    HTML(\"<br>\"),\n    fluidPage(\"Created by William Ngiam\")\n  ),\n  dashboardBody(\n    useShinyjs(),  # Initialize shinyjs\n    fluidRow(\n      box(title = \"Document Viewer\", width = 6, solidHeader = TRUE, status = \"primary\",\n          fluidPage(\n            fluidRow(\n              column(width = 5,\n                     numericInput(inputId = \"documentID_viewer\",\n                                  label = \"Document #\",\n                                  value = \"currentDocumentID\")),\n              column(width = 5,\n                     offset = 1,\n                     HTML(\"<strong>Document Navigation <\/strong><br>\"),\n                     actionButton(\"prevDocument\", \"Previous\"),\n                     actionButton(\"nextDocument\", \"Next\")))),\n          bootstrapPage(\n            tags$style(\n              \"#textDisplay {\n                    overflow: auto;\n                    max-height: 50vh;\n                }\"\n            ),\n            uiOutput(\"textDisplay\"),\n            tags$script('\n                          function getSelectionText() {\n                            var text = \"\";\n                            if (window.getSelection) {\n                              text = window.getSelection().toString();\n                            } else if (document.selection) {\n                              text = document.selection.createRange().text;\n                            }\n                            return text;\n                          }\n                          \n                          document.onmouseup = document.onkeyup = document.onselectionchange = function() {\n                            var selection = getSelectionText();\n                            Shiny.onInputChange(\"extract\",selection);\n                          };\n                          ')\n          )),\n      box(title = \"Quick Look\", width = 6, solidHeader = TRUE, status = \"primary\",\n          fluidPage(\n            DTOutput(\"counterTable\")\n          )\n      )\n      #box(title = \"Themes\", width = 3, solidHeader = TRUE, status = \"primary\")\n    ),\n    fluidRow(\n      box(title = \"Codebook\", width = 12, solidHeader = TRUE, status = \"primary\",\n          actionButton(\"addSelectedText\", \"Add Selected Text as Extract\"),\n          actionButton(\"deleteExtract\", \"Delete Extract from Codebook\"),\n          DTOutput(\"codebookTable\")))\n  )\n)\n\n### SERVER ###\nserver <- function(input, output, session) {\n  # Reactive values to store data and codebook\n  values <- reactiveValues(\n    corpus = NULL, # the text data to be analysed\n    documentTextColumn = NULL, # the column which contains document text\n    selectedText = NULL,\n    codebook = tibble(Theme = as.character(), \n                      Code = as.character(), \n                      Extract = as.character(), \n                      Document_ID = as.numeric()),\n    counter = data.frame(),\n    currentDocumentIndex = 1,\n    nDocuments = 1,\n    selection = NULL,\n    thisExtract = NULL\n  )\n  \n  ### FUNCTIONS ###\n  # Update text display based on currentDocumentIndex and documentTextColumn\n  updateTextDisplay <- function() {\n    req(values$corpus, values$documentTextColumn)\n    text <- values$corpus[[values$documentTextColumn]][values$currentDocumentIndex]\n    text <- sub(\"<span*/span>\",\"\",text) # Remove any leftover HTML\n    text <- gsub(pattern = \"\\n\", replacement = \" \", text) # Remove line breaks\n    \n    # Add highlights here by adding HTML tags to text\n    # Retrieve document ID\n    currentDoc <- values$currentDocumentIndex\n    \n    # Get saved extracts for document ID\n    currentExtracts <- values$codebook %>% \n      dplyr::filter(Document_ID == currentDoc)\n    oldStrings = currentExtracts$Extract\n    \n    if (length(oldStrings) > 0) {\n      # Detect where extracts start and finish in text\n      stringLocs <- as.data.frame(str_locate(text,paste0(\"\\\\Q\",oldStrings,\"\\\\E\")))\n      stringLocs <- na.omit(stringLocs) # omit NA where matches don't work with special characters\n      \n      # Sort these locations by their starting order\n      stringLocs <- stringLocs %>% \n        arrange(start)\n      \n      # If more than one string, check for overlaps (leetcode 56)\n      if (length(oldStrings) > 1) {\n        # Write the first interval to start result\n        reducedStrings <- tibble(start = as.numeric(),\n                                 end = as.numeric()) %>% \n          tibble::add_row(start = head(stringLocs$start, n = 1), \n                          end = head(stringLocs$end, n = 1))\n        \n        for (i in 1:nrow(stringLocs)) {\n          # Retrieve the next interval\n          thisStringStart <- stringLocs$start[i]\n          thisStringEnd <- stringLocs$end[i]\n          # Check for overlap\n          if (between(thisStringStart,\n                      tail(reducedStrings, n = 1)$start,tail(reducedStrings, n = 1)$end)) {\n          # If overlap, change value of interval\n            reducedStrings[nrow(reducedStrings),ncol(reducedStrings)] = max(thisStringEnd,tail(reducedStrings, n = 1)$end)\n          }\n          else {\n            # If no overlap, add the interval\n            reducedStrings <- reducedStrings %>% \n              add_row(start = thisStringStart, end = thisStringEnd)\n          }\n        }\n        # Arrange in descending order for inserting HTML\n        stringLocs <- reducedStrings %>% \n          arrange(desc(start))\n      }\n      \n      for (i in 1:nrow(stringLocs)) {\n        # Get start and end\n        stringStart <- stringLocs$start[i]\n        stringEnd <- stringLocs$end[i]\n        theString <- str_sub(text,stringStart,stringEnd)\n        # Get string\n        str_sub(text,stringStart,stringEnd) <- paste0(\"<span style=\\\"background-color: powderblue\\\">\",theString,\"<\/span>\")\n      }\n    }\n    \n    # Hope it works\n    output$textDisplay <- renderUI({\n      tags$div(id = \"textDisplay\",\n               tags$p(HTML(text), id = \"currentText\", style = \"font-size: 20px\"))\n    })\n  }\n  \n  # Update document viewer ID number\n  updateDocumentID <- function() {\n    updateNumericInput(\n      session,\n      inputId = \"documentID_viewer\",\n      value = values$currentDocumentIndex,\n      max = values$nDocuments)\n  }\n  \n  # Save codebook locally\n  saveCodebook <- function() {\n    req(values$codebook)\n    write.csv(values$codebook, \"temp_codebook.csv\", row.names = FALSE)\n  }\n  \n  # Render codebook\n  renderCodebook <- function() {\n    output$codebookTable <- renderDT({\n      datatable(values$codebook, editable = TRUE, rownames = FALSE, options = list(order = list(3, 'desc')))\n    })\n  }\n  \n  # Render code counter\n  renderCounter <- function() {\n    values$counter <- values$codebook %>% \n      count(Code, name = \"Instances\")\n    \n    output$counterTable <- renderDT({\n      datatable(values$counter, \n                editable = list(target = \"cell\",\n                                disable = list(columns = 1)),\n                rownames = FALSE)\n    })\n  }\n  \n  ### UPLOADING DATA ###\n  # Load corpus CSV file and update column selector\n  observeEvent(input$corpusFile, {\n    req(input$corpusFile)\n    values$corpus <- read.csv(input$corpusFile$datapath, stringsAsFactors = FALSE)\n    colnames <- colnames(values$corpus)\n    values$documentTextColumn <- colnames[1]  # Default to the first column\n    values$currentDocumentIndex <- 1  # Reset index on new file load\n    values$nDocuments <- nrow(values$corpus) # Get number of documents\n    \n    output$documentTextSelector <- renderUI({\n      req(values$corpus)\n      selectInput(\"documentTextColumn\", \"Select Text Column\",\n                  choices = colnames,\n                  selected = values$documentTextColumn)\n    })\n    \n    updateTextDisplay()\n    renderCodebook()\n    renderCounter()\n    \n    updateSelectInput(session, \"codebookSelector\", choices = values$codebook$Theme, selected = NULL)\n  })\n  \n  # Update codebook on upload\n  observeEvent(input$codebookFile, {\n    req(input$codebookFile)\n    values$codebook <- read.csv(input$codebookFile$datapath, stringsAsFactors = FALSE)\n    colnames <- colnames(values$codebook)\n    renderCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  \n  ## DOCUMENT NAVIGATION ##\n  # Update display after document text column is selected\n  observeEvent(input$documentTextColumn, {\n    values$documentTextColumn <- input$documentTextColumn\n    updateTextDisplay()\n  })\n  \n  # Updated display after document ID is scrolled\n  observeEvent(input$documentID_viewer, {\n    req(values$corpus)\n    if (input$documentID_viewer > nrow(values$corpus)) {\n      values$currentDocumentIndex <- nrow(values$corpus)\n      updateTextDisplay()\n    } else if (values$currentDocumentIndex > 1) {\n      values$currentDocumentIndex <- input$documentID_viewer\n      # Updated text display\n      updateTextDisplay()\n    }\n  })\n  \n  # Action button for previous document\n  observeEvent(input$prevDocument, {\n    req(values$corpus)\n    if (values$currentDocumentIndex > 1) {\n      values$currentDocumentIndex <- values$currentDocumentIndex - 1\n      \n      # Updated text display\n      updateDocumentID()\n      updateTextDisplay()\n      \n    }\n  })\n  \n  # Action button for next document\n  observeEvent(input$nextDocument, {\n    req(values$corpus)\n    if (values$currentDocumentIndex < nrow(values$corpus)) {\n      values$currentDocumentIndex <- values$currentDocumentIndex + 1\n      updateDocumentID()\n      updateTextDisplay()\n    }\n  })\n  \n  ## CODEBOOK ACTIONS ##\n  # Save after any edits to the codebook\n  observeEvent(input$codebookTable_cell_edit, {\n    values$codebook <- editData(values$codebook, input$codebookTable_cell_edit, rownames = FALSE, 'codebookTable')\n    saveCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  # Add selected text as extract\n  observeEvent(input$addSelectedText, {\n    req(values$codebook,input$extract)\n    selectedText <- input$extract # Highlighted text within document to-be-extracted\n    \n    # Append the selected text to codebook as extract\n    values$codebook <- values$codebook %>% \n      add_row(Theme = \"\",\n              Code = \"\",\n              Extract = selectedText,\n              Document_ID = values$currentDocumentIndex)\n    \n    renderCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  # Delete extract from codebook\n  observeEvent(input$deleteExtract, {\n    req(input$codebookTable_rows_selected)\n    whichRow <- input$codebookTable_rows_selected # highlighed rows in codebook\n    values$codebook <- values$codebook[-whichRow,]\n    renderCodebook()\n    renderCounter()\n    updateTextDisplay()\n  })\n  \n  # Save and apply rewording of code\n  observeEvent(input$counterTable_cell_edit, {\n    # Update counter\n    values$counter <- editData(values$counter, input$counterTable_cell_edit, rownames = FALSE, 'counterTable')\n    \n    ## Get previous code value\n    # Recreate previous counter\n    oldCounterTable <- values$codebook %>% \n      count(Code, name = \"Instances\")\n    \n    # Retrieve old Code\n    info = input$counterTable_cell_clicked\n    changeRow = info$row\n    changeCol = info$col\n    oldValue = info$value\n    \n    # Retrieve new Code\n    new_info = input$counterTable_cell_edit\n    newValue = new_info$value\n    \n    # Replace strings in codebook\n    values$codebook$Code[values$codebook$Code == oldValue] <- as.character(newValue)\n    \n    renderCodebook()\n  })\n  \n  # Download handler for the codebook\n  output$downloadData <- downloadHandler(\n    filename = function() {\n      paste(\"codebook-\", Sys.Date(), \".csv\", sep = \"\")\n    },\n    content = function(file) {\n      write.csv(values$codebook, file, row.names = FALSE)\n    }\n  )\n}\n\nshinyApp(ui, server)","type":"text"}]
